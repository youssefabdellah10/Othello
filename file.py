from fpdf import FPDF
from tabulate import tabulate
# Create a class inheriting from FPDF
class PDF(FPDF):
    def header(self):
        self.set_font('Arial', 'B', 12)
        self.cell(0, 10, 'Search Algorithm Comparison', align='C', ln=True)

    def chapter_title(self, title):
        self.set_font('Arial', 'B', 12)
        self.cell(0, 10, title, ln=True)

    def chapter_body(self, body):
        self.set_font('Arial', '', 12)
        self.multi_cell(0, 10, body)

# Create PDF instance
pdf = PDF()
pdf.add_page()

# Add table content
table_content = """
| Algorithm            | Description                                                                                                                                                                                                                   | Optimal | Complete | Time Complexity | Space Complexity | Advantage                                                                                                      | Disadvantage                                                                                                  |
|----------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------|----------|-----------------|------------------|---------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| Breadth-First Search  | Explores all neighbor nodes at the present depth before moving on to the next level, ensuring the shallowest goal node is found first.                                                                                         | Yes     | Yes      | O(b^d)          | O(b^d)           | Finds the shallowest goal, guarantees optimal solution for uniform cost, complete if branching factor is finite | Requires significant memory for large branching factors, may be inefficient for deep or infinite paths           |
| Depth-First Search    | Explores as far as possible along each branch before backtracking, potentially getting stuck in deep branches without finding the goal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | No      | No       | O(b^m)          | O(bm)            | Memory efficient, suitable for large state spaces, can find solutions quickly in some cases                     | Not optimal, may get stuck in infinite paths, does not guarantee the shortest path                                |
| Uniform-Cost Search   | Expands nodes with the lowest path cost so far, ensuring the optimal path is found but may be inefficient if costs vary significantly.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Yes     | Yes      | O(b^(C*/ε))     | O(b^(C*/ε))      | Guarantees optimal solution, efficient for uniform step costs, complete if step costs are non-negative            | Inefficient for varying step costs, exponential time complexity in some cases                                      |
| Depth-Limited Search  | Limits the depth of exploration to avoid infinite paths but may miss the goal if the depth limit is too shallow.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | No      | Yes      | O(b^l)          | O(bl)            | Avoids infinite paths, reduces memory usage compared to DFS, complete if depth limit is sufficient               | May miss the goal if depth limit is too shallow, not optimal                                                        |
| Iterative Deepening   | Repeatedly applies depth-limited search with increasing depth limits until the goal is found, combining the benefits of depth-first and breadth-first search.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Yes     | Yes      | O(b^d)          | O(bd)            | Guarantees optimal solution, combines advantages of DFS and BFS, complete if branching factor is finite            | Redundant work at each iteration, may be inefficient for large state spaces                                          |
| Bidirectional Search  | Simultaneously explores from the start and goal nodes, meeting in the middle to find the shortest path, reducing search time in some cases.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Yes     | Yes      | O(b^(d/2))      | O(b^(d/2))       | Efficient for finding shortest paths, reduces search time, complete and optimal if both searches are BFS            | Requires keeping at least one frontier in memory, may lose completeness or optimality with different search combinations |
| Greedy Best-First     | Expands the node that is closest to the goal based on a heuristic function, making decisions based solely on immediate information without considering future costs.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | No      | No       | O(b^m)          | O(bm)            | Efficient for heuristic-guided search, reduces memory usage compared to A*, can be faster in some cases              | Not optimal, may get stuck in local optima, incomplete without systematic checking of repeated states                |
| A* Search             | Evaluates nodes by combining the cost-so-far and the estimated cost-to-go using a heuristic function, ensuring optimality and efficiency by considering both actual and expected costs.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Yes     | Yes      | Exponential     | Keeps all expanded nodes in memory | Optimal and efficient, guarantees the shortest path, complete with consistent heuristic, balances actual and estimated costs | Exponential time complexity, requires memory for all expanded nodes                                               |
| IDA* Search           | Iterative deepening A* search that repeatedly applies A* with increasing cost limits until the goal is found, optimizing memory usage while maintaining optimality.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Yes     | Yes      | Exponential     | Linear           | Optimizes memory usage, guarantees optimality, complete with consistent heuristic, efficient for large state spaces | Exponential time complexity, may have redundant work at each iteration                                             |
| Beam Search           | Focuses on a predetermined number of most promising paths (beams) at each level, reducing memory requirements but potentially missing the optimal solution if the beam width is too narrow.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | No      | Yes      | O(b^d)          | O(b^d)           | Reduces memory usage, faster than A* in some cases, efficient for large state spaces                                | Not optimal, may miss the optimal solution if beam width is too narrow, limited exploration of the solution space     |
"""

pdf.chapter_body(table_content)

# Save the PDF
pdf_file_name = "search_algorithm_comparison.pdf"
pdf.output(pdf_file_name)

print(f"PDF saved as '{pdf_file_name}'")
